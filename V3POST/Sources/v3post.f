!******************************************************************************
!  File v3post.f
!  Under CVS control at logjam.gat.com
!  Use CVS keyword expansion:
!    $Revision: 1.37 $
!    $Author: hansonj $
!    $Date: 2010/07/20 20:11:41 $ (last committed)
!    $Name:  $
!    $Source: /home/cvs/V3POST/Sources/v3post.f,v $
!*******************************************************************************
!**********************************************************************
!**                                                                  **
!**   MAIN PROGRAM:  Compute Magnetic signals from VMEC equilibrium  **
!**                                                                  **
!**                                                                  **
!**     SUBPROGRAM DESCRIPTION:                                      **
!**          v3post generates various magnetic signals using         **
!**	     tables produced by v3rfun                                 **
!**                                                                  **
!**     CALLING ARGUMENTS: This is a stand alone code                **
!**          xv3post arg1 arg2                                       **
!**          arg1: optional input namelist file name                 **
!**          arg2: optional (only present if arg1 present)           **
!**                extension of wout file (replaces ideqfile)        **
!**                                                                  **
!**     Author: Lang Lao, with contributions from                    **
!**             J. Hanson, S. Hirshman                               **
!**                                                                  **
!**     REFERENCES:                                                  **
!**          (1)                                                     **
!**                                                                  **
!**********************************************************************
!-------------------------------------------------------------------------------
!   DEPENDENCIES
!-------------------------------------------------------------------------------
!
!    This file uses the following modules:
!       stel_kinds
!       stel_constants
!       read_response_nompi
!       response_arrays ! No longer JDH 06.28.2003
!       ezcdf
!       read_wout_mod
!       safe_open_mod 
!       v3post_data
!
!-------------------------------------------------------------------------------
!   CHANGE HISTORY
!-------------------------------------------------------------------------------
!
!  See Section V, at end of file
!
!-------------------------------------------------------------------------------
!   USAGE
!-------------------------------------------------------------------------------
!
!  Executing 'xv3post -h' will printout a help message
!
!  There are three input files read in by xv3post:
! 1) A namelist input file
!      The first argument on the execute line is the name of this file
!      If there is no argument on the execute line, the default name of the
!         namelist input file is v3post.in
!      For example, 'xvpost my_nl_file' reads namelist input from a file named
!         my_nl_file
!
! 2) A "wout" file
!       The name of the wout file is specified in the namelist input variable
!       "ideqfile". This file contains the specification of the magnetic field
!       generating coils. 
!
! 3) The response tables written by v3rfun
!       The name of the diagnostics LIST file and "crfun" files are specified 
!       in the namelist input variable
!
!  The output file generated by xv3post:
! 1) netCDF signals file v3post_"input_extension"
!      
!-------------------------------------------------------------------------------
!   COMMENTS
!-------------------------------------------------------------------------------
!
!  Note: output variables are declared in module v3post_data
!

!  There is an entry point NO_COIL in subroutine get_coil_v3p
!  that is invoked for analysis of fixed boudary equilibria

!
! An output example follows:
! netcdf v3post_vmec.098549.91905 {
! dimensions:
!         dim_00020 = 20 ;
!         dim_00006 = 6 ;
! variables:
!         char signal_diag_sname(dim_00006, dim_00020) ;
!         double signal_diag_cal(dim_00006) ;
!         double signal_diag_cext(dim_00006) ;
! data:
! 
!  signal_diag_sname =
!   "PSF7FA              ",
!   "PSI6A               ",
!   "MPI6FA322           ",
!   "MPI6NA322           ",
!   "PSF5A               ",
!   "PSF9A               " ;
! 
!  signal_diag_cal = -0.353951763160689, -0.347728438809365, 0.351377874351173, 
!     0.343478244875355, 1.33553911368407, 0.40503631737237 ;
! 
!  signal_diag_cext = -2.34897124852883, -3.42552073449518, 0.230719980228151, 
!     0.222717087857239, 0.726060810729332, -0.864062434590175 ;
! }

!*******************************************************************************
!  CODE V3POST
!    
! SECTION I.	MAIN PROGRAM
! SECTION II.	PRIMARY SUBROUTINES (CALLED FROM MAIN)
! SECTION III.	AUXILIARY SUBROUTINES
! SECTION IV.	COMMENTS FOR DIFFERENT REVISIONS
!*******************************************************************************

!*******************************************************************************
! SECTION I. MAIN PROGRAM
!*******************************************************************************

      PROGRAM v3post
!**     MAIN PROGRAM:  COMPUTE MAGNETIC SIGNALS                      **
!**     SUBPROGRAM DESCRIPTION:                                      **
!**          v3post computes magnetic responses given a magnetic     **
!**	     diagnostic set and an equilibrium                           **
!**                                                                  **
      USE stel_kinds
      USE v3post_rfun
      IMPLICIT NONE

!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      REAL(rprec) :: t1, t2
      REAL(rprec) :: ton, toff
      CHARACTER (len=120) :: plasfcn=' ', coilfcn=' '
!-----------------------------------------------
!  Start of Executable Code
!-----------------------------------------------
      CALL second0(t1)

!----------------------------------------------------------------------
!-- Open input file (v3post.ext), and read plasma equilibrium and v3post namelist--
!----------------------------------------------------------------------
      CALL get_input_v3p (plasfcn, coilfcn)	!	reads the namelist
!----------------------------------------------------------------------
!-- Compute magnetic signals due to external coils                   --
!----------------------------------------------------------------------
! Note that second0 is a timing routine in LIBSTELL
      CALL second0(ton)
      IF (freeb) CALL get_coil_v3p (coilfcn)
      IF (.not.freeb) CALL no_coil (plasfcn)
      CALL second0(toff)
CEAL      WRITE (6, 100)                                                        
CEAL     &   ' TIME TO COMPUTE EXTERNAL COIL SIGNALS (GET_COIL_V3P): ',         
CEAL     &    toff - ton
!----------------------------------------------------------------------
!-- Compute plasma contribution                                      --
!----------------------------------------------------------------------
      CALL get_plasma_v3p (plasfcn)
!----------------------------------------------------------------------
!-- Outputs                                                          --
!----------------------------------------------------------------------
      CALL write_out_v3p
      CALL second0(t2)
      PRINT 120, t2-t1, n_diagn_c

 100  FORMAT(a,1pe12.3)
 120  FORMAT(
     1 /,' TIME IN V3POST CODE:',1pe12.2,' SEC FOR ',i4.4,' SENSORS')
      END PROGRAM v3post

!*******************************************************************************
! SECTION II. PRIMARY SUBROUTINES (CALLED FROM MAIN)
!*******************************************************************************

!----------------------------------------------------------------------
!----------------------------------------------------------------------

      SUBROUTINE get_coil_v3p (coilfilename)
!**     SUBPROGRAM DESCRIPTION:                                      **
!**          get_coil_v3p computes external coil contribution        **
!**                                                                  **
      USE stel_kinds
      USE stel_constants
      USE v3post_rfun
!      USE response_arrays
      USE read_response_nompi
      USE safe_open_mod                  
      USE read_wout_mod, ONLY: mgrid_mode, extcur, ns
      IMPLICIT NONE

!-----------------------------------------------
!   D u m m y   A r g u m e n t s
!-----------------------------------------------
      CHARACTER*(*) , INTENT(in) :: coilfilename

!-----------------------------------------------
!   L o c a l   V a r i a b l e s
!-----------------------------------------------
      INTEGER(iprec) :: i, j=100, istat

!  Declaration of derived type, for coil response function
      TYPE(clresfun) crf
!  Local declaration of coil response pointer, sizes
!  JDH 06.28.2003. Note that n_diagn_c is in module v3post_rfun,
!     and n_diagn_c needs to be conveyed to get_plasma_v3p
      REAL(rprec), DIMENSION(:,:), POINTER :: cl_response
      INTEGER(iprec) :: n_field_cg
      
!-----------------------------------------------
!  Start of Executable Code
!-----------------------------------------------
!----------------------------------------------------------------------
!-- Get external coil response functions                             --
!-- Read external coil currents from wout file                       --
!----------------------------------------------------------------------
      IF (mgrid_mode == 'N') THEN
         WRITE (6, '(a,/,a)')' Old-style extcur array in wout file',
     1         ' Assuming "Scaled" mode for extcur data'
         mgrid_mode = 'S'
      END IF

      CALL cdf_crfun_read_nompi(TRIM(coilfilename),crf,                              & 
     &    istat, mmode=mgrid_mode)
      IF (istat .ne. 0) THEN
         PRINT *,' In get_coil_v3p, there was an error reading',
     1           ' cdf file: ', TRIM(coilfilename)
         STOP
      END IF

!  Point cl_response to component from derived type
      cl_response => crf%rdiag_coilg

!  Define local variable (n_field_cg) and module v3post_rfun variable
!    (n_diagn_c) for array sizes
      n_diagn_c = SIZE(cl_response,1)
      n_field_cg = SIZE(cl_response,2)
      IF (n_diagn_c .ne. crf%n_diagn_c) STOP 'get_coil_v3p #1'
      IF (n_field_cg .ne. crf%n_field_cg) STOP 'get_coil_v3p #2'
         
      IF (ANY(cl_response .eq. zero))                                          & 
     &    PRINT *,' In V3POST, some coil responses are zero'
 
!----------------------------------------------------------------------
      IF (.not. ALLOCATED(extcur)) STOP 'not free boundary'
      IF (SIZE(extcur) .ne. n_field_cg) WRITE(6,*)
     1    'Warning: external coil/wout nextcur mismatch'

!----------------------------------------------------------------------
!-- Allocate flux loop and magnetic probe signals                    --
!----------------------------------------------------------------------
      IF (ALLOCATED(signal_diag)) DEALLOCATE (signal_diag)
      ALLOCATE (signal_diag(n_diagn_c))
!----------------------------------------------------------------------
!-- Compute magnetic responses due to external coils                 --
!----------------------------------------------------------------------
      signal_diag(1:n_diagn_c)%cal = zero
      DO i = 1, MIN(n_field_cg, SIZE(extcur))
        signal_diag(1:n_diagn_c)%cal =
     &            signal_diag(1:n_diagn_c)%cal
     &          + cl_response(1:n_diagn_c,i)*extcur(i)
      END DO
      signal_diag(1:n_diagn_c)%cext = signal_diag(1:n_diagn_c)%cal
!
      RETURN

!----------------------------------------------------------------------
!----------------------------------------------------------------------

      ENTRY no_coil (coilfilename)
! set n_diagn_c
      CALL safe_open(j, istat, TRIM(coilfilename), 'old', 'formatted')
      IF (istat .ne. 0) STOP 'safe_open'
      DO WHILE (istat .eq. 0)
        READ (j, *, iostat=istat, end=10005) n_diagn_c
10005 CONTINUE
      END DO
      IF (ALLOCATED(signal_diag)) DEALLOCATE (signal_diag)
      ALLOCATE (signal_diag(n_diagn_c))
      signal_diag(1:n_diagn_c)%cal = zero
      signal_diag(1:n_diagn_c)%cext = zero

      CLOSE (j)

      END SUBROUTINE get_coil_v3p

!----------------------------------------------------------------------
!----------------------------------------------------------------------

      SUBROUTINE get_input_v3p (plasfcn, coilfcn)
      USE stel_kinds
      USE stel_constants
      USE v3post_rfun
!      USE response_arrays
      USE read_response_nompi
      USE safe_open_mod
      USE read_wout_mod, ONLY: read_wout_file
      IMPLICIT NONE
!----------------------------------------------------------------------
! D U M M Y Arguments Declarations
!----------------------------------------------------------------------
      CHARACTER (len=*) :: plasfcn, coilfcn
!----------------------------------------------------------------------
! L O C A L Variable Declarations
!----------------------------------------------------------------------
!  JDH 2010-07-20 Commented out below - not needed. Replaced with declaration
!    without EXTERNAL.
!      INTEGER , EXTERNAL :: iargc
      INTEGER :: iargc
      INTEGER :: numargs, istat, ierr, nin=100
      CHARACTER (len=100)  ::  input_id, ideq_cmdline
      CHARACTER (len=100)  :: listin
      NAMELIST/v3p_in/listin, idrfun, eqtype, ideqfile, myid, freeb,
     &                lsurf
      REAL(rprec) :: ton, toff
      
!-----------------------------------------------
!  Start of Executable Code
!-----------------------------------------------
      CALL second0(ton)

!----------------------------------------------------------------------
!  Parse the execute line: 2nd arg added by SPH (09/11/03) to pass
!                          wout file extension for use in STELLOPT          
!----------------------------------------------------------------------
      numargs = iargc()
      IF (numargs == 0) THEN
         input_id = 'v3post.in'
      ELSE
         CALL getarg (1, input_id)
         IF (numargs > 1) CALL getarg(2, ideq_cmdline)
      ENDIF
      IF (TRIM(input_id) .eq. '-h') THEN
         CALL help
         STOP ' -h option halts execution'
      ENDIF

!----------------------------------------------------------------------
!-- open input/output units                                          --
!----------------------------------------------------------------------
      CALL safe_open(nin, istat, TRIM(input_id), 'old', 'formatted')
      IF (istat .ne. 0) STOP 'safe_open iostat != 0 in v3post'
!----------------------------------------------------------------------
!-- read inputs from namelist                                        --
!----------------------------------------------------------------------
      READ (nin, nml=v3p_in)
      CLOSE(nin)

      IF (numargs > 1) ideqfile = TRIM(ideq_cmdline)
      IF (TRIM(myid) .eq. 'none') myid=' '
      plasfcn = TRIM(listin)
      coilfcn = "crfun_"//TRIM(idrfun)//".nc"
      IF (myid(1:1) .ne. ' ') coilfcn=
     .	"crfun_"//TRIM(idrfun)//"_"//TRIM(myid)//".nc"
!      PRINT*,"old coilfcn=",trim(coilfcn)
      IF (myid(1:1) .ne. ' ') coilfcn=
     .  "crfun"//TRIM(myid)//"_"//TRIM(idrfun)//".nc"
!      PRINT*,"new coilfcn=",trim(coilfcn)      
!
!----------------------------------------------------------------------
!-- read VMEC equilibrium from wout                                  --
!----------------------------------------------------------------------
        eq_file = 'wout_' // TRIM(ideqfile)
        CALL  read_wout_file(eq_file, ierr)
        IF (ierr .ne. 0) THEN
           WRITE (6,*) 'Error reading wout file: ierr = ', ierr
           STOP
        END IF
 5000 FORMAT (/,10x,'v3post Version ',a,/)

      CALL second0(toff)
CEAL      WRITE (6, '(a,1pe12.3)')
CEAL     1' TIME TO READ VMEC EQUILIBRIUM (GET_INPUT_V3P): ', toff - ton

      END SUBROUTINE get_input_v3p


      SUBROUTINE get_plasma_v3p(plasfcn)
!**     SUBPROGRAM DESCRIPTION:                                      **
!**          get_plasma_v3p gets plasma contribution                 **
!**                                                                  **
      USE stel_kinds
      USE stel_constants
      USE v3post_rfun
      USE read_wout_mod, ONLY: nfp, phi, ns, lasym
!      USE response_arrays
      USE read_response_nompi
      USE safe_open_mod
      USE bivariate
      USE spline_parm
      IMPLICIT NONE

!----------------------------------------------------------------------
! D U M M Y Arguments Declarations
!----------------------------------------------------------------------
      CHARACTER*(*) , INTENT(in) :: plasfcn

!----------------------------------------------------------------------
! L O C A L Variable Declarations
!----------------------------------------------------------------------
!  JDH. Move from response_arrays to here. 06.28.2003.
!        REAL(rprec), DIMENSION(:,:,:,:),                                       &
!     &          TARGET, ALLOCATABLE :: pl_response
!  SPH: Make into a pointer, faster
!        REAL(rprec), DIMENSION(:,:,:,:),                                       &
!     &           ALLOCATABLE :: pl_response
      REAL(rprec), DIMENSION(:,:), POINTER :: pl_response


      INTEGER(iprec)               :: m, i, j, k, mc, mdiag, ib, nsize
      INTEGER(iprec)               :: ifilst=20, istat, listcount
      CHARACTER(len=200)           :: listfilename
      REAL(rprec), ALLOCATABLE, DIMENSION(:,:,:) :: pl_respsuv
      REAL(rprec), ALLOCATABLE, DIMENSION(:,:) :: sumsuv
      REAL(rprec), ALLOCATABLE, DIMENSION(:) :: pl_respns
      REAL(rprec), ALLOCATABLE, DIMENSION(:,:) :: bsubuns, bsubvns
      REAL(rprec) :: sumtot, delsuv, signphi, deluv

      REAL(rprec), ALLOCATABLE, DIMENSION(:) :: sum1k
      
      REAL(rprec) :: fperiod
      REAL(rprec) :: splintim1, splintim2, sumtim1, sumtim2, 
     1               sumavec1, sumavec2, tstart, tend,
     2               tseton, tsetoff
      REAL(rprec) :: splintim=0, sumtim=0, sumavec=0, sumsize=0

      REAL        ::  tdif, tm_begin, tm_end
      TYPE (prfun) :: a1
! Spline variables
      INTEGER(iprec), PARAMETER :: n111   = 1
      LOGICAL :: lspline = .false.
      LOGICAL :: lfirst
!----------------------------------------------------------------------
!--   cbspl, wbspl      : working array                              --
!--   bkx, bky          : coefficient arrays                         --
!--   lkx, lky          : # of terms in bkx, bky                     --
!--   iebspl            : error flag                                 --
!--   pbspl             : output arrays                              --
!--   lspline           : = true, use bicubic splines;               --
!--                       = false, use 4 pt interpolation            --
!----------------------------------------------------------------------
      REAL(rprec) :: cbspl(kubicx,lubicx,kubicy,lubicy), wbspl(nwrk)
      REAL(rprec) :: bkx(lubicx+1),bky(lubicy+1)
      REAL(rprec) :: pbspl(6)
      INTEGER(iprec) :: iebspl, lkx, lky
! end Spline variables
      
!-----------------------------------------------
!  Start of Executable Code
!-----------------------------------------------
      IF (eqtype.eq.'none') RETURN

      CALL second0(tstart)
      lfirst = .not.lspline
      IF (lsurf) THEN
        ib = ns
      ELSE
        ib = 1
      ENDIF
!----------------------------------------------------------------------
!-- call once for dims                                               --
!-- open names file for reading                                      --
!----------------------------------------------------------------------
      CALL safe_open(ifilst, istat, TRIM(plasfcn), 'old', 'formatted')
      IF (istat .ne. 0) THEN
         WRITE(6,*)' Error opening file: ',TRIM(plasfcn)
         STOP 
      END IF
      READ (ifilst,'(i5,a)', iostat=istat) listcount, listfilename
      IF (istat .ne. 0) THEN
         WRITE (6, *) 'Error reading list file ' // TRIM(listfilename)
         STOP
      END IF
      CLOSE (ifilst)
!----------------------------------------------------------------------
!-- read ancillary data                                              --
!----------------------------------------------------------------------
      CALL cdf_prfun_read_nompi
     &	(TRIM(listfilename),a1,istat,ldim_only=.true.)
      IF (istat .ne. 0) THEN
         WRITE(*,*) 'Error reading ', listfilename,' in get_plasma_v3p'
         STOP
      END IF
      
      ALLOCATE (shortnames(n_diagn_c))
      mdiag=n_diagn_c

!      ir=boxdims(1); jz=boxdims(2); kp=boxdims(3)
!      rmin=rzphibox(1); rmax=rzphibox(2)
!      zmin=rzphibox(3); zmax=rzphibox(4)

      ir = a1%ir
      jz = a1%jz
      kp = a1%kp
      kp_store = a1%kp_store
      rmin = a1%rmin
      rmax = a1%rmax
      zmin = a1%zmin
      zmax = a1%zmax
      n_field_periods = a1%n_field_periods
      lstell_sym = a1%lstell_sym
!      WRITE(6,*) 'ir, jz, kp, kp_store, lstell_sym', ir, jz, kp,               
!     &    kp_store, lstell_sym
     
      IF (ALLOCATED(sum1k)) DEALLOCATE (sum1k)
      ALLOCATE (sum1k(kp_store))
      
!      IF (ALLOCATED(pl_response)) DEALLOCATE (pl_response)
!      ALLOCATE (pl_response(ir,jz,kp_store,3))
     
!----------------------------------------------------------------------
!-- set up (R,P,Z) cylindrical grids                                 --
!----------------------------------------------------------------------
      IF (.not.ALLOCATED(rgrid)) THEN
        ALLOCATE (rgrid(ir))
        ALLOCATE (zgrid(jz))
!        ALLOCATE (pgrid(kp))
      ENDIF
      fperiod = twopi / n_field_periods
      delr = (rmax - rmin) / (ir - 1)
      delz = (zmax - zmin) / (jz - 1)
      delp = fperiod / kp
      DO i = 1, ir
        rgrid(i) = rmin + (i - 1) * delr
      END DO
      DO i = 1, jz
        zgrid(i) = zmin + (i - 1) * delz
      END DO
!      DO i = 1, kp
!        pgrid(i) = (i - 1) * delp
!      END DO
!----------------------------------------------------------------------
!-- read equilibrium, check sign of toroidal flux                    --
!----------------------------------------------------------------------
      CALL second0(tseton)
      CALL setup_plasma_v3p(ib)
      CALL second0(tsetoff)

      IF (n_field_periods .ne. nfp) THEN
        WRITE (6,*) n_field_periods, nfp
        STOP  'n_field_periods .ne. nfp'
      ENDIF
      signphi = one
      IF  (phi(ns).lt.zero) signphi = -one
      deluv = delu*delv
      delsuv = dels*deluv
!----------------------------------------------------------------------
!-- Allocate arrays                                                  --
!----------------------------------------------------------------------
      IF (.not.ALLOCATED(signal_diag)) THEN
        ALLOCATE (signal_diag(n_diagn_c))
        signal_diag(1:n_diagn_c)%cal = zero
      ENDIF
      IF (ALLOCATED(sumsuv)) DEALLOCATE (sumsuv)
      ALLOCATE (sumsuv(ns, ju))
      IF ((.not.ALLOCATED(bsubuns)).and.(lsurf)) THEN
         ALLOCATE(bsubuns(ju,kv))
         ALLOCATE(bsubvns(ju,kv))
         ALLOCATE(pl_respns(ju))
      END IF
      IF (lsurf) THEN
        bsubuns(:,:) = 1.5_rprec*bsubu(ns,:,:) -
     &                           0.5_rprec*bsubu(ns-1,:,:)
        bsubvns(:,:) = 1.5_rprec*bsubv(ns,:,:) -
     &                           0.5_rprec*bsubv(ns-1,:,:)
      END IF
!----------------------------------------------------------------------
!-- open names file for reading                                      --
!----------------------------------------------------------------------
      CALL safe_open(ifilst, istat, TRIM(plasfcn), 'old', 'formatted')
      IF (istat .ne. 0) STOP 'safe_open error reading diagnostics list'

CEAL      CALL safe_open(iout, istat,"v3post_log" // '.' // TRIM(ideqfile),  &
CEAL     &               'replace', 'formatted')
CEAL
CEAL     1      'Time (ms)    Size (Kb)'

CEAL      WRITE(iout,*)'diag#               filename             ',
CEAL     1            'time(ms) size(bytes)   total bytes'            
!----------------------------------------------------------------------
!-- Compute magnetic responses due to plasma for each sensor         --
!----------------------------------------------------------------------
      DIAGNO: DO m = 1, n_diagn_c
!----------------------------------------------------------------------
!-- get plasma response functions                                    --
!----------------------------------------------------------------------
         READ (ifilst,'(i5,a)',iostat=istat) 
     1         listcount,listfilename
         IF (istat .ne. 0) EXIT DIAGNO
         IF (LEN_TRIM(listfilename) .LE. 0) CYCLE DIAGNO
 !        PRINT *,' Diagnostic #', listcount,
 !    1           ' Reading: ', TRIM(listfilename)

!----------------------------------------------------------------------
!-- read plasma resonse function                                              --
!----------------------------------------------------------------------
         CALL second0(sumavec1)
         CALL CPU_TIME(tm_begin)

         CALL cdf_prfun_read_nompi(TRIM(listfilename),a1,istat)

         CALL CPU_TIME(tm_end)
         CALL second0(sumavec2)
         tdif = tm_end - tm_begin
         IF (istat .ne. 0) THEN
             WRITE (6, *) 
     &       ' In get_plasma_v3p, error reading list file: ',
     &         TRIM(listfilename), ' for sensor: ', m
             CYCLE
         END IF
         
         shortnames(m)=TRIM(a1%s_name)
         
!  JDH 06.29.2003. Copying into pl_response adds about 20% time.
!         pl_response(:,:,:,1) = a1%a_r(:,:,:)
!         pl_response(:,:,:,2) = a1%a_f(:,:,:)
!         pl_response(:,:,:,3) = a1%a_z(:,:,:)
         

         sumavec = sumavec + (sumavec2 - sumavec1)
!         IF (istat .ne. 0) GOTO 10005

         CALL getfilesize(TRIM(listfilename), nsize)

CEAL         WRITE (6, "(3x,i4.4,2x,a36,3x,f6.1,6x,i7)") listcount,             
CEAL     &      ADJUSTL(listfilename), 1000*(sumavec2-sumavec1),                
CEAL     &      nsize/1000

         sumsize = sumsize + nsize
CEAL         WRITE(iout,fmt='(1x,i4.4,1x,a36,1x,f5.1,3x,i9,x,i15)')                & 
CEAL     &	   listcount, TRIM(listfilename), tdif*1000, nsize,                  &
CEAL     &       INT(sumsize, kind=8)

!----------------------------------------------------------------------
!--  allocation                                                      --
!----------------------------------------------------------------------
         IF (.not.ALLOCATED(pl_respsuv))
     &            ALLOCATE(pl_respsuv(ns,ju,3))
!----------------------------------------------------------------------
!-- loop over each toroidal plane                                    --
!----------------------------------------------------------------------
        sumtot = zero
!        TOR_PLANE: DO k = 1, kv
        TOR_PLANE: DO k = 1, kp_store

          CALL second0(splintim1)
          DO mc = 1, 3
            SELECT CASE (mc)
               CASE (1) 
                  pl_response => a1%a_r(:,:,k)
               CASE (2) 
                  pl_response => a1%a_f(:,:,k)
               CASE (3) 
                  pl_response => a1%a_z(:,:,k)
            END SELECT
            IF (lspline) THEN
!----------------------------------------------------------------------
!-- bicubic interpolate response tables                              --
!----------------------------------------------------------------------
               CALL sets2d(pl_response,cbspl,rgrid,ir,bkx,
     &                     lkx,zgrid,jz,bky,lky,wbspl,iebspl)
               DO i = ib, ns
               DO j = 1, ju
                  CALL seva2d(bkx,lkx,bky,lky,cbspl,ir,jz,rsuv(i,j,k),
     &                        zsuv(i,j,k),pbspl,iebspl,n111)
                  pl_respsuv(i,j,mc) = pbspl(1)
               END DO
               END DO
            ELSE ! IF (lspline)
!----------------------------------------------------------------------
!-- bivariate (4 pt) interpolation response tables                  ---
!----------------------------------------------------------------------
               IF (lfirst .and. mc.eq.1) THEN
                  CALL setbivariate (rsuv(:,:,k), zsuv(:,:,k),
     &                               rgrid, zgrid, k, kv, ib)
               END IF
               IF (.not.(lsurf)) THEN
                  CALL bivariate4pt (pl_response, pl_respsuv(1,1,mc), k)
               ELSE
                  CALL bivariate4pt (pl_response, pl_respns(1), k)
                  pl_respsuv(ns,:,mc) = pl_respns(:)
               END IF
            END IF ! IF (lspline)
          END DO ! mc
          CALL second0(splintim2)
          splintim=splintim+splintim2-splintim1
!----------------------------------------------------------------------
!-- form plasma response integral (R=1, PHI=2, Z=3)                  --
!----------------------------------------------------------------------
          CALL second0(sumtim1)
          IF (lsurf) THEN
             sumsuv(ns,:) = pl_respsuv(ns,:,1)
     &                    *(bsubuns(:,k)*rvsuv(ns,:,k)  
     &                    - bsubvns(:,k)*rusuv(ns,:,k)) 
     &                    + pl_respsuv(ns,:,2)
     &                    * bsubuns(:,k)*rsuv(ns,:,k)
     &                    + pl_respsuv(ns,:,3)
     &                    *(bsubuns(:,k)*zvsuv(ns,:,k)  
     &                    - bsubvns(:,k)*zusuv(ns,:,k))
            sum1k(k) = SUM(sumsuv(ns,:))
          ELSE
             sumsuv(:,:) = currusuv(:,:,k)
     &                   *(rusuv(:,:,k)*pl_respsuv(:,:,1) 
     &                   + zusuv(:,:,k)*pl_respsuv(:,:,3)) 
     &                   + currvsuv(:,:,k)
     &                   *(rvsuv(:,:,k)*pl_respsuv(:,:,1) 
     &                   + zvsuv(:,:,k)*pl_respsuv(:,:,3) 
     &                   + rsuv (:,:,k)*pl_respsuv(:,:,2))
             sum1k(k) =  SUM(sumsuv(2:ns,:) + sumsuv(1:ns-1,:))/2
          END IF
          CALL second0(sumtim2)
          sumtim = sumtim+sumtim2-sumtim1
        END DO TOR_PLANE
        
        sumtot = SUM(sum1k)
        IF (lstell_sym) THEN
           IF (lasym) THEN
              WRITE(*,*) 'Problem: diagostics assume stell symmetry'
              WRITE(*,*) 'While equilibrium is asymmetric'
              WRITE(*,*) 'lstell_sym, lasym',lstell_sym, lasym
           ELSE
              sumtot = sumtot - (sum1k(1) + sum1k(kp_store)) / 2
           END IF
        END IF

        lfirst = .false.
        IF (lsurf) THEN
          sumtot = -sumtot*deluv/mu0
        ELSE
          sumtot = -sumtot*delsuv
        END IF
        signal_diag(m)%cal = signal_diag(m)%cal + sumtot
      END DO DIAGNO

!      DEALLOCATE (pl_respsuv, sumsuv, pl_response)
      DEALLOCATE (pl_respsuv, sumsuv)

      CLOSE (ifilst)
CEAL      CLOSE (iout)

      CALL second0(tend)
      WRITE (6,*)
      WRITE (6,'(2(a,3i6))')
     &   ' ns, ju, kv : ', ns, ju, kv,
     &   ' ir, jz, kv : ', ir, jz, kv
      WRITE (6, 100)
     1   ' TIME TO COMPUTE PLASMA RESPONSES (GET_PLASMA_V3P): ', 
     1    tend - tstart
      WRITE (6, 100)
     1   ' (a) TIME TO READ RESPONSE TABLES :   ', sumavec
!      WRITE (6, *)'	FOR ',mdiag,' DIAGNOSTICS'
!      WRITE (6, *)'	with a maximum table size ',
!     1	int(a1size*8+247),' bytes'
      IF (lspline) THEN
         WRITE (6, 100) 
     1   ' (a) TIME FOR SPLINE INTERPOLATION:   ', splintim
      ELSE
         CALL clear_bivar
         WRITE (6, 100) 
     1   ' (b) TIME FOR BILINEAR INTERPOLATION: ', splintim
      END IF

      WRITE (6, 100)
     1   ' (c) TIME FOR RESPONSE INTEGRALS:     ', sumtim
      WRITE (6, 100)
     1   ' (d) TIME FOR EQUILIBRIUM SETUP :     ', tsetoff-tseton

 100  FORMAT(a,1pe12.3)

      END SUBROUTINE get_plasma_v3p
!----------------------------------------------------------------------
!----------------------------------------------------------------------
      SUBROUTINE setup_plasma_v3p(ib)
!**********************************************************************
!**                                                                  **
!**     MAIN PROGRAM:  COMPUTE MAGNETIC SIGNALS                      **
!**                                                                  **
!**                                                                  **
!**     SUBPROGRAM DESCRIPTION:                                      **
!**          setup_plasma_v3p sets grid and computes current densty      **
!**                       components                                 **
!**                                                                  **
      USE stel_kinds
      USE stel_constants
      USE v3post_rfun
      USE read_wout_mod
!      USE response_arrays
      IMPLICIT NONE
      INTEGER, INTENT(in) :: ib
      INTEGER(iprec) :: i, j, k, js
      REAL(rprec)    :: fperiod
      REAL(rprec), DIMENSION(:), ALLOCATABLE :: cosz, sinz
      REAL(rprec), DIMENSION(:,:), ALLOCATABLE :: cosu, sinu, 
     1                                            cosv, sinv
!
      IF (eqtype.eq.'none') RETURN
!----------------------------------------------------------------------
!-- get plasma contribution                                          --
!----------------------------------------------------------------------
        ju = ns
!  JDH 06.28.2003. Getting rid of boxdims
!    kp comes through v3post_rfun, and is defined in get_plasma_v3p.
!        kv = boxdims(3)
        kv = kp
        fperiod = twopi / n_field_periods
        dels = one / (ns - 1)
        delu = twopi / ju
        delv = fperiod / kv
!----------------------------------------------------------------------
!-- allocate arrays                                                  --
!----------------------------------------------------------------------
        IF (ALLOCATED(sgrid)) DEALLOCATE (sgrid)
        IF (ALLOCATED(ugrid)) DEALLOCATE (ugrid)
        IF (ALLOCATED(vgrid)) DEALLOCATE (vgrid)
        IF (ALLOCATED(rsuv)) DEALLOCATE (rsuv)
        IF (ALLOCATED(gsuv)) DEALLOCATE (gsuv)
        IF (ALLOCATED(zsuv)) DEALLOCATE (zsuv)
!        IF (ALLOCATED(psuv)) DEALLOCATE (psuv)
        IF (ALLOCATED(currusuv)) DEALLOCATE (currusuv)
        IF (ALLOCATED(currvsuv)) DEALLOCATE (currvsuv)
        IF (ALLOCATED(rusuv)) DEALLOCATE (rusuv)
        IF (ALLOCATED(zusuv)) DEALLOCATE (zusuv)
        IF (ALLOCATED(rvsuv)) DEALLOCATE (rvsuv)
        IF (ALLOCATED(zvsuv)) DEALLOCATE (zvsuv)
        ALLOCATE (sgrid(ns),ugrid(ju),vgrid(kv),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (rsuv(ns,ju,kv),zsuv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (gsuv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
!        ALLOCATE (psuv(ns,ju,kv))
        ALLOCATE (currusuv(ns,ju,kv),currvsuv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (rusuv(ns,ju,kv),zusuv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (rvsuv(ns,ju,kv),zvsuv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (cosz(mnmax), sinz(mnmax),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (cosu(mnmax, ju), sinu(mnmax, ju),
     &            cosv(mnmax, kv), sinv(mnmax, kv),stat=i)
        IF (i .ne. 0) GOTO 1000
!----------------------------------------------------------------------
!-- Allocate arrays for surface formulation                          --
!----------------------------------------------------------------------
        IF (ALLOCATED(bsubu)) DEALLOCATE (bsubu)
        IF (ALLOCATED(bsubv)) DEALLOCATE (bsubv)
        ALLOCATE (bsubu(ns,ju,kv),bsubv(ns,ju,kv),stat=i)
        IF (i .ne. 0) GOTO 1000
!----------------------------------------------------------------------
!-- set up (s,u,v) VMEC flux grids                                   --
!----------------------------------------------------------------------
        DO i = 1, ns
          sgrid(i) = (i - 1) * dels
        END DO
        DO i = 1, ju
          ugrid(i) = (i - 1) * delu
          cosu(:,i) = COS(xm*ugrid(i))
          sinu(:,i) = SIN(xm*ugrid(i))
        END DO
        DO i = 1, kv
          vgrid(i) = (i - 1) * delv
          cosv(:,i) = COS(xn*vgrid(i))
          sinv(:,i) = SIN(xn*vgrid(i))
        END DO

        IF (lsurf) THEN
           bsubu(1:ns-2,:,:) = 0;    bsubv(1:ns-2,:,:) = 0
           rsuv(1:ns-1,:,:) = 0;     zsuv(1:ns-1,:,:) = 0
           rusuv(1:ns-1,:,:) = 0;    zusuv(1:ns-1,:,:) = 0
           rvsuv(1:ns-1,:,:) = 0;    zvsuv(1:ns-1,:,:) = 0
           gsuv(1:ns-1,:,:) = 0
        END IF
   
!
!       DO FOURIER MODE SUM IN INNERMOST LOOP
!       FIRST DO mnmax-sized ARRAYS (r, z)
!
        DO j = 1, ju
        DO k = 1, kv
!          zetamn = xm*ugrid(j) - xn*vgrid(k)
!          cosz = COS(zetamn)
!          sinz = SIN(zetamn)
          cosz = cosu(:,j)*cosv(:,k) + sinu(:,j)*sinv(:,k)
          sinz = sinu(:,j)*cosv(:,k) - cosu(:,j)*sinv(:,k)
          DO js = ib, ns
            rsuv(js,j,k) = SUM(rmnc(:,js)*cosz)
            zsuv(js,j,k) = SUM(zmns(:,js)*sinz)
            rusuv(js,j,k) = -SUM(xm*rmnc(:,js)*sinz)
            zusuv(js,j,k) = SUM(xm*zmns(:,js)*cosz)
            rvsuv(js,j,k) = SUM(xn*rmnc(:,js)*sinz)
            zvsuv(js,j,k) = -SUM(xn*zmns(:,js)*cosz)
          END DO

!----------------------------------------------------------------------
!-- stellarator asymmetric terms                                     --
!----------------------------------------------------------------------
          IF (lasym) THEN
            DO js = ib, ns
              rsuv(js,j,k) = rsuv(js,j,k) + SUM(rmns(:,js)*sinz)
              zsuv(js,j,k) = zsuv(js,j,k) + SUM(zmnc(:,js)*cosz)
              rusuv(js,j,k) = rusuv(js,j,k) + SUM(xm*rmns(:,js)*cosz)
              zusuv(js,j,k) = zusuv(js,j,k) - SUM(xm*zmnc(:,js)*sinz)
              rvsuv(js,j,k) = rvsuv(js,j,k) - SUM(xn*rmns(:,js)*cosz)
              zvsuv(js,j,k) = zvsuv(js,j,k) + SUM(xn*zmnc(:,js)*sinz)
            END DO
          ENDIF
        END DO
        END DO

        DEALLOCATE (cosz, sinz, cosu, cosv, sinu, sinv)

!
!       NEXT DO mnmax_nyq-sized ARRAYS (g, curru,v, bsubu,v)
!
        ALLOCATE (cosz(mnmax_nyq), sinz(mnmax_nyq),stat=i)
        IF (i .ne. 0) GOTO 1000
        ALLOCATE (cosu(mnmax_nyq, ju), sinu(mnmax_nyq, ju),
     &            cosv(mnmax_nyq, kv), sinv(mnmax_nyq, kv),stat=i)
        IF (i .ne. 0) GOTO 1000

        DO i = 1, ju
          cosu(:,i) = COS(xm_nyq(:)*ugrid(i))
          sinu(:,i) = SIN(xm_nyq(:)*ugrid(i))
        END DO
        DO i = 1, kv
          vgrid(i) = (i - 1) * delv
          cosv(:,i) = COS(xn_nyq(:)*vgrid(i))
          sinv(:,i) = SIN(xn_nyq(:)*vgrid(i))
        END DO

        DO j = 1, ju
        DO k = 1, kv
!          zetamn = xm_nyq*ugrid(j) - xn_nyq*vgrid(k)
!          cosz = COS(zetamn)
!          sinz = SIN(zetamn)
          cosz = cosu(:,j)*cosv(:,k) + sinu(:,j)*sinv(:,k)
          DO js = ib, ns
            gsuv(js,j,k) = SUM(gmnc(:,js)*cosz)
            currusuv(js,j,k) = SUM(currumnc(:,js)*cosz)
            currvsuv(js,j,k) = SUM(currvmnc(:,js)*cosz)
          END DO

          IF (lsurf) THEN
            DO js = ns-1, ns
               bsubu(js,j,k) = SUM(bsubumnc(:,js)*cosz)
               bsubv(js,j,k) = SUM(bsubvmnc(:,js)*cosz)
            END DO
          END IF

!----------------------------------------------------------------------
!-- stellarator asymmetric terms                                     --
!----------------------------------------------------------------------
          IF (lasym) THEN
            sinz = sinu(:,j)*cosv(:,k) - cosu(:,j)*sinv(:,k)
            DO js = ib, ns
              gsuv(js,j,k) = gsuv(js,j,k) + SUM(gmns(:,js)*sinz)
              currusuv(js,j,k) = currusuv(js,j,k) 
     &                                    + SUM(currumns(:,js)*sinz)
              currvsuv(js,j,k) = currvsuv(js,j,k)
     &                                    + SUM(currvmns(:,js)*sinz)
            END DO
            IF (lsurf) THEN
              DO js = ns-1, ns
                 bsubu(js,j,k) = bsubu(js,j,k)+SUM(bsubumns(:,js)*sinz)
                 bsubv(js,j,k) = bsubv(js,j,k)+SUM(bsubvmns(:,js)*sinz)
              END DO
            END IF
          ENDIF
        END DO
        END DO

        DEALLOCATE (cosz, sinz, cosu, cosv, sinu, sinv)

        RETURN

 1000 CONTINUE
        STOP 'Memory allocation error in setup_plasma_v3p!'

      END SUBROUTINE setup_plasma_v3p


!----------------------------------------------------------------------
!----------------------------------------------------------------------
      SUBROUTINE write_out_v3p
!**     SUBPROGRAM DESCRIPTION:                                      **
!**        write output netcdf file                                  **
!**                                                                  **
      USE stel_kinds
      USE stel_constants
      USE v3post_rfun
      USE read_response_nompi
      USE ezcdf
      IMPLICIT NONE
!----------------------------------------------------------------------
! L O C A L Variable Declarations
!----------------------------------------------------------------------
      INTEGER(iprec) :: istat, ncdf, index_nc
      REAL(rprec), DIMENSION(:), ALLOCATABLE :: signal_plasma
      LOGICAL :: lnc
      CHARACTER (LEN=100) :: cdffil
      CHARACTER (LEN=*), PARAMETER :: 
     1  vn_cal = 'signal_diag_cal',
     2  vn_cext = 'signal_diag_cext',
     3  vn_plasma = 'signal_diag_plasma',
     4  vn_sname = 'signal_diag_sname'
      CHARACTER (LEN=*), PARAMETER, DIMENSION(1) ::
     1             d1dim = (/'num_diagno'/)
      CHARACTER*(*), DIMENSION(2), PARAMETER :: 
     1             d2dim = (/'str_len   ','num_diagno'/)
!----------------------------------------------------------------------
!  JDH 10.06.03. Changed cdffil assignment below, as per EL's request.
      cdffil='v3post' // TRIM(myid) // '_' // TRIM(ideqfile)
      index_nc = INDEX(cdffil,".nc",BACK=.TRUE.)
      lnc = (index_nc .eq. (LEN_TRIM(cdffil)-2))
      IF(.not.lnc) cdffil = TRIM(cdffil) // '.nc'

!  JDH 10.06.03. I don't understand the purpose of the renaming of
!  cdffil, within the IF test, below.
      IF (.not. ALLOCATED(shortnames)) THEN	           ! as in  vactest
        ALLOCATE(shortnames(SIZE(signal_diag%cal)))
        cdffil='v3post_' // TRIM(idrfun)
        index_nc = INDEX(cdffil,".nc",BACK=.TRUE.)
        lnc = (index_nc .eq. (LEN_TRIM(cdffil)-2))
        IF (.not.lnc) cdffil=TRIM(cdffil) // '.nc'
        shortnames='UNDEFINED'
      ENDIF

      ALLOCATE(signal_plasma(SIZE(signal_diag%cal)))
      signal_plasma = signal_diag%cal - signal_diag%cext

      CALL cdf_open(ncdf, TRIM(cdffil), 'w', istat)
      CALL cdf_define(ncdf, vn_sname, shortnames, dimname=d2dim)
      CALL cdf_define(ncdf, vn_cal, signal_diag%cal, dimname=d1dim)
      CALL cdf_define(ncdf, vn_cext, signal_diag%cext, dimname=d1dim)
      CALL cdf_define(ncdf, vn_plasma, signal_plasma, dimname=d1dim)
      CALL cdf_write(ncdf, vn_sname, shortnames)
      CALL cdf_write(ncdf, vn_cal, signal_diag%cal)
      CALL cdf_write(ncdf, vn_cext, signal_diag%cext)
      CALL cdf_write(ncdf, vn_plasma, signal_plasma)
      CALL cdf_close(ncdf)

      DEALLOCATE (signal_plasma)
      IF (ALLOCATED(shortnames)) DEALLOCATE (shortnames)

      END SUBROUTINE write_out_v3p

!----------------------------------------------------------------------
!----------------------------------------------------------------------


!----------------------------------------------------------------------
!----------------------------------------------------------------------

!*******************************************************************************
! SECTION IV.	AUXILIARY SUBROUTINES
!*******************************************************************************

!----------------------------------------------------------------------
!----------------------------------------------------------------------

      SUBROUTINE help
      WRITE(*,*) 'FILE NAME is the single ARGUMENT'
      WRITE(*,*) 'If there is NO ARGUMENT file name DEFAULTS to :'
      WRITE(*,*) '  v3post.in'
      WRITE(*,*) 'An input namelist specification SAMPLE is :'
      WRITE(*,fmt='(a)')
     &'   &v3p_in ',
     &'    idrfun  = ''d3d_eqtest'' ',
     &'    listin = ''diagnostic.d3d_eqtest.LIST'' ',
     &'    freeb = ''T OR F'' ',
     &'    myid = ''a user tag used in a previous xrfun run'' ',
     &'    ideqfile = ''vmec.098549.91905.nc'' ',
     &'    eqtype  = ''vmec OR none'' ',
     &'    lsurf = ''T OR F'' ',
     &'  / '
!
      WRITE(*,*) 'END HELP'
!
      END SUBROUTINE help

!----------------------------------------------------------------------
!----------------------------------------------------------------------
!*******************************************************************************
! SECTION V.	OLD (SUPERSEDED) SUBROUTINES
!*******************************************************************************


!*******************************************************************************
! SECTION VI.	COMMENTS FOR DIFFERENT REVISIONS
!*******************************************************************************
!**          22/04/02..........first created                         **

!  01.02.2003
!    Moved coding that was in test_rfun into a separate program.
!    Left the subroutine there, but it doesn't do anything.

!  01.02.2003
!    Eliminated some extraneous variables. Revised i/o unit number variable names.
!    Completely eliminated test_rfun.

!  01.20.2003
!    Changed plasma response function so that it gets multiplied by
!    diagnostic_coils % coils(k) % raux. This does unit conversion for magnetic probes.
!    Add logicals for writing binary coil response file, and for reading a coils_dot file.
!
!  01.23.2003
!    Finished eliminating the unformatted (binary) file writ of the plasma response.
!    Added separate variables for n_field_periods from NLI and Coils_dot. Logic
!    for which to use is in subroutine get_input_v3p.
!
!  04.11.2004 SPH
!    Added logic to check on mode (Raw, Scaled, or unknown) that extcur array was
!    produced in.
!
!  04.16.2003 LLL
!    Added surface formulation.
!
!  06.27.2003 JDH
!    Added coding for using Stellarator Symmetry. Moved setup_plasma_v3p_old to 
!    separate section.
!
!  06.28.2003 JDH
!    Going a bit slower, trying to avoid very odd bug.
!    Consolidated some printout stuff. Eliminate call to get_response, replaced with
!    call to cdf_crfun_read_nompi.
!    Get rid of rzphibox and boxdims. Eliminate setup_plasma_v3p_old - unused.
!    Moved pl_response from response_arrays module, and eliminated response_arrays
!
!  06.29.2003 JDH
!    Changed pl_reponse so that it is no longer a target. Now, component arrays
!    from the Type(prfun) variable a1 are copied into pl_response.
!    Coded so setting stellarator symmetry to T now works. (lstell_sym)
!
!  8.15.2003 JDH
!   SPH had done some revisions to eliminate unnecessary moving of the
!   plasma resonse function information.
!   JDH 8.15 - slight change in call to cdf_prfun_read_nompi. Also fixed some logic in
!   module read_response_nompi
!
!  9.30.2003 SPH
!   Added "dimname" to netcdf output file.
!   Added second command line arg (wout file extension, w or w/o .nc) to replace ideqfile
!   in v3post input file. Useful if called with possibly varying ideqfile extensions.
!
!  10.06.03 JDH
!    Changed cdffil assignment in subroutine write_out_v3p.
!    Changed fort.113 to a named file, "v3post_log.ext", to run correctly in multitasking env
!
!  12.16.03 SPH
!    Fixed setup_plasma_v3p to use new mnmax_nyq - sized arrays from read_wout_mod
!
!  07.15.04 SPH
!    As per request from E. Lazarus, changed mgrid_mode to "S" (scaled) for old-style mgrid file 
!    (formerly, when "N" passed for "No-mode", we treated it like "R" mode).
